/*
	Dustin Yost 0984932
	EGP-405-02
	Lab1
	09/03/2017
	We certify that this work is entirely our own.
	The assessor of this project may reproduce this project and provide
	copies to other academic staff, and/or communicate a copy of this project
	to a plagiarism-checking service, which may retain a copy of
	the project on its database.
*/
#include <cstdlib>

#include <stdio.h>
#include "RakNet/RakPeerInterface.h"

#include <string.h>
#include "RakNet/MessageIdentifiers.h"

#include "RakNet/BitStream.h"
#include "RakNet/RakNetTypes.h"  // MessageID

//#define MAX_CLIENTS 10
//#define SERVER_PORT 60000

using namespace RakNet;

enum GameMessages
{
	ID_GAME_MESSAGES = ID_USER_PACKET_ENUM,

	// Handshake exchange
	// Client->Server; client responds to connection by sendings its username
	ID_USERNAME,
	// Server->Client; broadcast welcome message to all clients (a new client has joined)
	ID_NEW_CLIENT_JOINED,
	// Server->Client; server tells client its ID number
	ID_CLIENT_NUMBER,

	// Messaging
	// Client->Client; Client broadcast to some username (or all)
	ID_CHAT_MESSAGE,
	ID_COMMAND_REQUEST,

	// Misc
	ID_SEND_ALL, // used to notify incoming users of a list of current usernames active

};

#pragma pack(push, 1) // byte alignment, no padding
/*
struct PacketClientJoined {
	unsigned char packetId;
	char message[31];
};
//*/

// GameMessages::ID_USERNAME
// GameMessages::ID_NEW_CLIENT_JOINED
struct PacketUsername {
	unsigned char packetID;
	char username[31];
};

// GameMessages::ID_CLIENT_NUMBER
struct PacketClientNumber {
	unsigned char packetID;
	unsigned int clientID;
};

// GameMessages::ID_CHAT_MESSAGE
struct PacketChatMessage {
	unsigned char packetID;
	char username[31];
	char message[64];
};

#pragma pack(pop)

int main(void)
{
	char str[512];
	RakNet::RakPeerInterface *peer = RakNet::RakPeerInterface::GetInstance();
	bool isServer;
	RakNet::Packet *packet;

	unsigned int maxClients = 1;
	unsigned int serverPort = 1111;

	printf("(C) or (S)erver?\n");
	//gets(str);
	fgets(str, 512, stdin);
	if ((str[0] == 'c') || (str[0] == 'C'))
	{
		SocketDescriptor sd;
		peer->Startup(1, &sd, 1);
		isServer = false;
	}
	else {
		SocketDescriptor sd(serverPort, 0);
		peer->Startup(maxClients, &sd, 1);
		isServer = true;
	}

	if (isServer)
	{
		printf("Starting the server.\n");
		// We need to let the server accept incoming connections from the clients
		peer->SetMaximumIncomingConnections(maxClients);
	}
	else {
		printf("Enter server IP or hit enter for 127.0.0.1... ");
		//gets(str);
		fgets(str, 512, stdin);
		if (str[0] == '\n') {//0) {
			strcpy(str, "127.0.0.1");
		}
		printf("Starting the client.\n");
		peer->Connect(str, serverPort, 0, 0);

	}

	while (1)
	{
		for (packet = peer->Receive(); packet; peer->DeallocatePacket(packet), packet = peer->Receive())
		{
			switch (packet->data[0])
			{
				case ID_REMOTE_DISCONNECTION_NOTIFICATION:
					printf("Another client has disconnected.\n");
					break;
				case ID_REMOTE_CONNECTION_LOST:
					printf("Another client has lost the connection.\n");
					break;
				case ID_REMOTE_NEW_INCOMING_CONNECTION:
					printf("Another client has connected.\n");
					break;
				case ID_CONNECTION_REQUEST_ACCEPTED:
					{
						printf("Our connection request has been accepted.\n");

						// Use a BitStream to write a custom user message
						// Bitstreams are easier to use than sending casted structures, and handle endian swapping automatically
						/*
						RakNet::BitStream bsOut;
						bsOut.Write((RakNet::MessageID)ID_CLIENT_JOINED);
						bsOut.Write("Hello world");
						peer->Send(&bsOut, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);
						//*/

						RakNet::SystemAddress addressServer = packet->systemAddress;

						//PacketClientJoined clientJoined = { (RakNet::MessageID)ID_GAME_MESSAGES, "Hello World from client" };
						//peer->Send((char*)(&clientJoined), sizeof(clientJoined), HIGH_PRIORITY, RELIABLE_ORDERED, 0, addressServer, false);

						// Setup username packet
						PacketUsername packetUsername[1] = {GameMessages::ID_USERNAME, "Lucas123" }; // TODO: Prompt user for username
						peer->Send((char*)packetUsername, sizeof(packetUsername), HIGH_PRIORITY, RELIABLE_ORDERED, 0, addressServer, false);

					}
					break;
				case ID_USERNAME:
					{
						PacketUsername *packetUsername = (PacketUsername*)packet->data;
						// TODO:
						// this is the server, so store username (from packet) and put in a dictionary (with the current length of the dictionary, which is the user id)
						// Send PacketClientNumber back to the sender
						// Tell all users who just joined

						packetUsername->packetID = GameMessages::ID_NEW_CLIENT_JOINED;
						peer->Send((char*)packetUsername, sizeof(packetUsername), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, true); // if broadcast is true, raknet sends to all EXCEPT the specified address

						PacketClientNumber packetClientID[1] = { ID_CLIENT_NUMBER, 0 };
						peer->Send((char*)packetClientID, sizeof(packetClientID), HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress, false);

					}
					break;
				case ID_NEW_INCOMING_CONNECTION:
					printf("A connection is incoming.\n");
					break;
				case ID_NO_FREE_INCOMING_CONNECTIONS:
					printf("The server is full.\n");
					break;
				case ID_DISCONNECTION_NOTIFICATION:
					if (isServer) {
						printf("A client has disconnected.\n");
					}
					else {
						printf("We have been disconnected.\n");
					}
					break;
				case ID_CONNECTION_LOST:
					if (isServer) {
						printf("A client lost the connection.\n");
					}
					else {
						printf("Connection lost.\n");
					}
					break;
				case ID_GAME_MESSAGES:
					{
						/*
						RakNet::RakString rs;
						RakNet::BitStream bsIn(packet->data, packet->length, false);
						bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
						bsIn.Read(rs);
						printf("%s\n", rs.C_String());
						//*/
						//PacketClientJoined *clientJoined = (PacketClientJoined*)packet->data;
						//printf("%s\n", clientJoined->message);

					}
					break;
				default:
					printf("Message with identifier %i has arrived.\n", packet->data[0]);
					break;
			}
		}
	}

	RakNet::RakPeerInterface::DestroyInstance(peer);

	system("pause");
	return 0;
}
