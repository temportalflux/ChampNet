<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ChampNet: DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ChampNet
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_data_structures.html">DataStructures</a></li><li class="navelem"><a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_data_structures_1_1_multilist-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The multilist, representing an abstract data type that generally holds lists.  
 <a href="class_data_structures_1_1_multilist.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_d_s___multilist_8h_source.html">DS_Multilist.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8a37f6b9891411ea3e14410e8b12cfcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a37f6b9891411ea3e14410e8b12cfcb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Multilist</b> (const <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;source)</td></tr>
<tr class="separator:a8a37f6b9891411ea3e14410e8b12cfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebd3513d069580696df82f1ae805789"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ebd3513d069580696df82f1ae805789"></a>
<a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;source)</td></tr>
<tr class="separator:a3ebd3513d069580696df82f1ae805789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11484761bc2c4d578915db64e1945671"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11484761bc2c4d578915db64e1945671"></a>
_DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const _IndexType position) const </td></tr>
<tr class="separator:a11484761bc2c4d578915db64e1945671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3f119b9f715a88fc6dd356689f7e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#afe3f119b9f715a88fc6dd356689f7e72">Push</a> (const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="separator:afe3f119b9f715a88fc6dd356689f7e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f817a5d9980df4c4ad941a7edd6a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae75f817a5d9980df4c4ad941a7edd6a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Push</b> (const _DataType &amp;d, const _KeyType &amp;key, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="separator:ae75f817a5d9980df4c4ad941a7edd6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e7c33fe9587c1902ed1551d720f7b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09e7c33fe9587c1902ed1551d720f7b7"></a>
_DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a09e7c33fe9587c1902ed1551d720f7b7">Pop</a> (const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a09e7c33fe9587c1902ed1551d720f7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or removes and gets an element from the list, according to the same rules as <a class="el" href="class_data_structures_1_1_multilist.html#afe3f119b9f715a88fc6dd356689f7e72">Push()</a>. Ordered list is LIFO for the purposes of Pop and Peek. <br/></td></tr>
<tr class="separator:a09e7c33fe9587c1902ed1551d720f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac2e4785ce35dc061cd6b1cff5ac721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ac2e4785ce35dc061cd6b1cff5ac721"></a>
_DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Peek</b> (void) const </td></tr>
<tr class="separator:a8ac2e4785ce35dc061cd6b1cff5ac721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1596f547cb2b038726d2d733930e44be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1596f547cb2b038726d2d733930e44be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a1596f547cb2b038726d2d733930e44be">PushOpposite</a> (const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a1596f547cb2b038726d2d733930e44be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_data_structures_1_1_multilist.html#afe3f119b9f715a88fc6dd356689f7e72">Push()</a>, except FIFO and LIFO are reversed. Ordered list still inserts in order. <br/></td></tr>
<tr class="separator:a1596f547cb2b038726d2d733930e44be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813d673f3e74d35e078355e2652335ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a813d673f3e74d35e078355e2652335ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PushOpposite</b> (const _DataType &amp;d, const _KeyType &amp;key, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="separator:a813d673f3e74d35e078355e2652335ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5788e4bea29895d318226b5b943d5954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5788e4bea29895d318226b5b943d5954"></a>
_DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a5788e4bea29895d318226b5b943d5954">PopOpposite</a> (const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a5788e4bea29895d318226b5b943d5954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_data_structures_1_1_multilist.html#a09e7c33fe9587c1902ed1551d720f7b7" title="Gets or removes and gets an element from the list, according to the same rules as Push()...">Pop()</a> and Peek(), except FIFO and LIFO are reversed. <br/></td></tr>
<tr class="separator:a5788e4bea29895d318226b5b943d5954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014b1c5251d11ee2a51e6fac42fac019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a014b1c5251d11ee2a51e6fac42fac019"></a>
_DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>PeekOpposite</b> (void) const </td></tr>
<tr class="separator:a014b1c5251d11ee2a51e6fac42fac019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2192553f7ca8b678719cef4643d0d143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2192553f7ca8b678719cef4643d0d143"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a2192553f7ca8b678719cef4643d0d143">InsertAtIndex</a> (const _DataType &amp;d, _IndexType index, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a2192553f7ca8b678719cef4643d0d143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack,<a class="el" href="class_data_structures_1_1_queue.html" title="A queue implemented as an array with a read and write index. ">Queue</a>: Inserts at index indicated, elements are shifted. Ordered list: Inserts, position is ignored. <br/></td></tr>
<tr class="separator:a2192553f7ca8b678719cef4643d0d143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dd81344fc1e3ddada972637cfe27c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a33dd81344fc1e3ddada972637cfe27c3">RemoveAtIndex</a> (_IndexType position, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a33dd81344fc1e3ddada972637cfe27c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered list, removes at index indicated, swaps last element with that element. Otherwise, array is shifted left to overwrite removed element.  <a href="#a33dd81344fc1e3ddada972637cfe27c3">More...</a><br/></td></tr>
<tr class="separator:a33dd81344fc1e3ddada972637cfe27c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c83303215bacfc4510640efc062d39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c83303215bacfc4510640efc062d39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#aa3c83303215bacfc4510640efc062d39">RemoveAtKey</a> (_KeyType key, bool assertIfDoesNotExist, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:aa3c83303215bacfc4510640efc062d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of <em>key</em>, and remove at that index. <br/></td></tr>
<tr class="separator:aa3c83303215bacfc4510640efc062d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84be6225dbac07350dee2ff8a8210e17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84be6225dbac07350dee2ff8a8210e17"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a84be6225dbac07350dee2ff8a8210e17">GetIndexOf</a> (_KeyType key) const </td></tr>
<tr class="memdesc:a84be6225dbac07350dee2ff8a8210e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of <em>key</em>. Return -1 if the key is not found. <br/></td></tr>
<tr class="separator:a84be6225dbac07350dee2ff8a8210e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e4d9aacbd1b22979a50dcd91522735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e4d9aacbd1b22979a50dcd91522735"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#af0e4d9aacbd1b22979a50dcd91522735">GetInsertionIndex</a> (_KeyType key) const </td></tr>
<tr class="memdesc:af0e4d9aacbd1b22979a50dcd91522735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns where in the list we should insert the item, to preserve list order. Returns -1 if the item is already in the list. <br/></td></tr>
<tr class="separator:af0e4d9aacbd1b22979a50dcd91522735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af718a952c67cb8e19e9863f087101340"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af718a952c67cb8e19e9863f087101340"></a>
_DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#af718a952c67cb8e19e9863f087101340">GetPtr</a> (_KeyType key) const </td></tr>
<tr class="memdesc:af718a952c67cb8e19e9863f087101340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of <em>key</em>. Return 0 if the key is not found. Useful if _DataType is always non-zero pointers. <br/></td></tr>
<tr class="separator:af718a952c67cb8e19e9863f087101340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e49b2800f3cfebdc4fa22e3ded43689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e49b2800f3cfebdc4fa22e3ded43689"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a4e49b2800f3cfebdc4fa22e3ded43689">ForEach</a> (void(*func)(_DataType &amp;item, const char *file, unsigned int line), const char *file, unsigned int line)</td></tr>
<tr class="memdesc:a4e49b2800f3cfebdc4fa22e3ded43689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the list, calling the function pointer on each element. <br/></td></tr>
<tr class="separator:a4e49b2800f3cfebdc4fa22e3ded43689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde3bc96898c80714e3b0d12f907610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecde3bc96898c80714e3b0d12f907610"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ForEach</b> (void(*func)(_DataType &amp;item))</td></tr>
<tr class="separator:aecde3bc96898c80714e3b0d12f907610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d58006a5444efa6487d21faa8310bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d58006a5444efa6487d21faa8310bfe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a8d58006a5444efa6487d21faa8310bfe">IsEmpty</a> (void) const </td></tr>
<tr class="memdesc:a8d58006a5444efa6487d21faa8310bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the list is empty. <br/></td></tr>
<tr class="separator:a8d58006a5444efa6487d21faa8310bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ed61cd2124ffd01e0bab732f89e61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374ed61cd2124ffd01e0bab732f89e61"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a374ed61cd2124ffd01e0bab732f89e61">GetSize</a> (void) const </td></tr>
<tr class="memdesc:a374ed61cd2124ffd01e0bab732f89e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements used in the list. <br/></td></tr>
<tr class="separator:a374ed61cd2124ffd01e0bab732f89e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837e5a1793a397c26580de337c4a4207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a837e5a1793a397c26580de337c4a4207"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a837e5a1793a397c26580de337c4a4207">Clear</a> (bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a837e5a1793a397c26580de337c4a4207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the list. The list is not deallocated if it is small, unless <em>deallocateSmallBlocks</em> is true. <br/></td></tr>
<tr class="separator:a837e5a1793a397c26580de337c4a4207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea6e9cc49fa6c858114db3540264d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a8ea6e9cc49fa6c858114db3540264d7b">ClearPointers</a> (bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a8ea6e9cc49fa6c858114db3540264d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the list, first calling RakNet::OP_Delete on all items.  <a href="#a8ea6e9cc49fa6c858114db3540264d7b">More...</a><br/></td></tr>
<tr class="separator:a8ea6e9cc49fa6c858114db3540264d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d96ab0baeb2c566f3f5e0c20be880ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d96ab0baeb2c566f3f5e0c20be880ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a4d96ab0baeb2c566f3f5e0c20be880ed">ClearPointer</a> (_KeyType key, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a4d96ab0baeb2c566f3f5e0c20be880ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty one item from the list, first calling RakNet::OP_Delete on that item. <br/></td></tr>
<tr class="separator:a4d96ab0baeb2c566f3f5e0c20be880ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8cc2c4515e66ace8a1efe3d045eaf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8cc2c4515e66ace8a1efe3d045eaf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a1b8cc2c4515e66ace8a1efe3d045eaf0">ReverseList</a> (void)</td></tr>
<tr class="memdesc:a1b8cc2c4515e66ace8a1efe3d045eaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements in the list, and flips the sort order returned by <a class="el" href="class_data_structures_1_1_multilist.html#a800048ec6f280da5e7a161a22a43b87b" title="Returns true if ascending. ">GetSortOrder()</a> if <a class="el" href="class_data_structures_1_1_multilist.html#aacbab3fd63f299185141b0c4a62e9ef5" title="Returns true if the list is currently believed to be in a sorted state. ">IsSorted()</a> returns true at the time the function is called. <br/></td></tr>
<tr class="separator:a1b8cc2c4515e66ace8a1efe3d045eaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15148dd58d303f1f6d72ecf5d1663aea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15148dd58d303f1f6d72ecf5d1663aea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a15148dd58d303f1f6d72ecf5d1663aea">Reallocate</a> (_IndexType size, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>
<tr class="memdesc:a15148dd58d303f1f6d72ecf5d1663aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates the list to a larger size. If <em>size</em> is smaller than the value returned by <a class="el" href="class_data_structures_1_1_multilist.html#a374ed61cd2124ffd01e0bab732f89e61" title="Returns the number of elements used in the list. ">GetSize()</a>, the call does nothing. <br/></td></tr>
<tr class="separator:a15148dd58d303f1f6d72ecf5d1663aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c98eb3dd4a13343695b810c5f6d2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#af7c98eb3dd4a13343695b810c5f6d2c4">Sort</a> (bool force)</td></tr>
<tr class="memdesc:af7c98eb3dd4a13343695b810c5f6d2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to already be sorted.  <a href="#af7c98eb3dd4a13343695b810c5f6d2c4">More...</a><br/></td></tr>
<tr class="separator:af7c98eb3dd4a13343695b810c5f6d2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d07bd2615004b6903a6ae8387238fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a3d07bd2615004b6903a6ae8387238fa9">TagSorted</a> (void)</td></tr>
<tr class="memdesc:a3d07bd2615004b6903a6ae8387238fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the list to be remembered as sorted.  <a href="#a3d07bd2615004b6903a6ae8387238fa9">More...</a><br/></td></tr>
<tr class="separator:a3d07bd2615004b6903a6ae8387238fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219bfa477ce7722e32462e97c6876634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a219bfa477ce7722e32462e97c6876634">SetSortOrder</a> (bool ascending)</td></tr>
<tr class="memdesc:a219bfa477ce7722e32462e97c6876634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaults to ascending.  <a href="#a219bfa477ce7722e32462e97c6876634">More...</a><br/></td></tr>
<tr class="separator:a219bfa477ce7722e32462e97c6876634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800048ec6f280da5e7a161a22a43b87b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a800048ec6f280da5e7a161a22a43b87b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a800048ec6f280da5e7a161a22a43b87b">GetSortOrder</a> (void) const </td></tr>
<tr class="memdesc:a800048ec6f280da5e7a161a22a43b87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if ascending. <br/></td></tr>
<tr class="separator:a800048ec6f280da5e7a161a22a43b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbab3fd63f299185141b0c4a62e9ef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#aacbab3fd63f299185141b0c4a62e9ef5">IsSorted</a> (void) const </td></tr>
<tr class="memdesc:aacbab3fd63f299185141b0c4a62e9ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the list is currently believed to be in a sorted state.  <a href="#aacbab3fd63f299185141b0c4a62e9ef5">More...</a><br/></td></tr>
<tr class="separator:aacbab3fd63f299185141b0c4a62e9ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a1eb26b60fc9742c3d9d842b1807cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3a1eb26b60fc9742c3d9d842b1807cc"></a>
<a class="el" href="_d_s___multilist_8h.html#a8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#ab3a1eb26b60fc9742c3d9d842b1807cc">GetMultilistType</a> (void) const </td></tr>
<tr class="memdesc:ab3a1eb26b60fc9742c3d9d842b1807cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns what type of list this is. <br/></td></tr>
<tr class="separator:ab3a1eb26b60fc9742c3d9d842b1807cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054b07faf5e383569219911f18615a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a054b07faf5e383569219911f18615a39">SetMultilistType</a> (<a class="el" href="_d_s___multilist_8h.html#a8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a> newType)</td></tr>
<tr class="memdesc:a054b07faf5e383569219911f18615a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes what type of list this is.  <a href="#a054b07faf5e383569219911f18615a39">More...</a><br/></td></tr>
<tr class="separator:a054b07faf5e383569219911f18615a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5958435ddcd5ac367ab0406fc797c00a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5958435ddcd5ac367ab0406fc797c00a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a5958435ddcd5ac367ab0406fc797c00a">FindIntersection</a> (<a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;source1, <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;source2, <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;intersection, <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;uniqueToSource1, <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;uniqueToSource2)</td></tr>
<tr class="memdesc:a5958435ddcd5ac367ab0406fc797c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of two lists. Intersection is items common to both lists. <br/></td></tr>
<tr class="separator:a5958435ddcd5ac367ab0406fc797c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a2c45e4975ecd892c7ecd0ebf368171d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>ML_UNSORTED</b>, 
<b>ML_SORTED_ASCENDING</b>, 
<b>ML_SORTED_DESCENDING</b>
 }</td></tr>
<tr class="separator:a2c45e4975ecd892c7ecd0ebf368171d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae51593f68d24493bce8497ef146254ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae51593f68d24493bce8497ef146254ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReallocateIfNeeded</b> (const char *file, unsigned int line)</td></tr>
<tr class="separator:ae51593f68d24493bce8497ef146254ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d422cd5abd6d957aa9f6ca4ef2b96b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d422cd5abd6d957aa9f6ca4ef2b96b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeallocateIfNeeded</b> (const char *file, unsigned int line)</td></tr>
<tr class="separator:ae6d422cd5abd6d957aa9f6ca4ef2b96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40d1b2609ef5ff466e335b9910b1f74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad40d1b2609ef5ff466e335b9910b1f74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReallocToSize</b> (_IndexType newAllocationSize, const char *file, unsigned int line)</td></tr>
<tr class="separator:ad40d1b2609ef5ff466e335b9910b1f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c65d0fb8699c772e27ab7b41d1d7528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c65d0fb8699c772e27ab7b41d1d7528"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseListInternal</b> (void)</td></tr>
<tr class="separator:a4c65d0fb8699c772e27ab7b41d1d7528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19491f8d38d094d0f42d7cbc80d76c2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19491f8d38d094d0f42d7cbc80d76c2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InsertInOrderedList</b> (const _DataType &amp;d, const _KeyType &amp;key)</td></tr>
<tr class="separator:a19491f8d38d094d0f42d7cbc80d76c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecfd97a885f59dc8c0c1115ae54503b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ecfd97a885f59dc8c0c1115ae54503b"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><b>GetIndexFromKeyInSortedList</b> (const _KeyType &amp;key, bool *objectExists) const </td></tr>
<tr class="separator:a8ecfd97a885f59dc8c0c1115ae54503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee663f800392364b9673b4d7d33547f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee663f800392364b9673b4d7d33547f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>InsertShiftArrayRight</b> (const _DataType &amp;d, _IndexType index)</td></tr>
<tr class="separator:aee663f800392364b9673b4d7d33547f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920a4857ce7b9d4844bd9efd96d27762"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a920a4857ce7b9d4844bd9efd96d27762"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteShiftArrayLeft</b> (_IndexType index)</td></tr>
<tr class="separator:a920a4857ce7b9d4844bd9efd96d27762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566e3d1a805abb95a633f4d2dadd2a5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566e3d1a805abb95a633f4d2dadd2a5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>QSortAscending</b> (_IndexType left, _IndexType right)</td></tr>
<tr class="separator:a566e3d1a805abb95a633f4d2dadd2a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7589930edbda9c6c34c4fccdab2d5d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7589930edbda9c6c34c4fccdab2d5d55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>QSortDescending</b> (_IndexType left, _IndexType right)</td></tr>
<tr class="separator:a7589930edbda9c6c34c4fccdab2d5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd3b8d06d3f7ddc2e1308c57ef602fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dd3b8d06d3f7ddc2e1308c57ef602fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopySource</b> (const <a class="el" href="class_data_structures_1_1_multilist.html">Multilist</a> &amp;source)</td></tr>
<tr class="separator:a1dd3b8d06d3f7ddc2e1308c57ef602fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acf634946f450bd5884fb3bcae33fd689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf634946f450bd5884fb3bcae33fd689"></a>
_DataType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#acf634946f450bd5884fb3bcae33fd689">data</a></td></tr>
<tr class="memdesc:acf634946f450bd5884fb3bcae33fd689"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of user values. <br/></td></tr>
<tr class="separator:acf634946f450bd5884fb3bcae33fd689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6561cddc98dd8ab653f56a4203a8ded"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6561cddc98dd8ab653f56a4203a8ded"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#ab6561cddc98dd8ab653f56a4203a8ded">dataSize</a></td></tr>
<tr class="memdesc:ab6561cddc98dd8ab653f56a4203a8ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the list. <br/></td></tr>
<tr class="separator:ab6561cddc98dd8ab653f56a4203a8ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6040ead73a8eed4667d92e7b66d13db9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6040ead73a8eed4667d92e7b66d13db9"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a6040ead73a8eed4667d92e7b66d13db9">allocationSize</a></td></tr>
<tr class="memdesc:a6040ead73a8eed4667d92e7b66d13db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of <em>array</em>. <br/></td></tr>
<tr class="separator:a6040ead73a8eed4667d92e7b66d13db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9278b3e4d57e3dedd3f613c78ead4461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9278b3e4d57e3dedd3f613c78ead4461"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a9278b3e4d57e3dedd3f613c78ead4461">queueHead</a></td></tr>
<tr class="memdesc:a9278b3e4d57e3dedd3f613c78ead4461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array index for the head of the queue. <br/></td></tr>
<tr class="separator:a9278b3e4d57e3dedd3f613c78ead4461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300a64c3629be9ece749f944c5d05525"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a300a64c3629be9ece749f944c5d05525"></a>
_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#a300a64c3629be9ece749f944c5d05525">queueTail</a></td></tr>
<tr class="memdesc:a300a64c3629be9ece749f944c5d05525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array index for the tail of the queue. <br/></td></tr>
<tr class="separator:a300a64c3629be9ece749f944c5d05525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5f425e786988300c1cc1c782173b4c"><td class="memItemLeft" align="right" valign="top">_IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_data_structures_1_1_multilist.html#aaa5f425e786988300c1cc1c782173b4c">preallocationSize</a></td></tr>
<tr class="separator:aaa5f425e786988300c1cc1c782173b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28ab4936d56170b875d73ede3b08443"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad28ab4936d56170b875d73ede3b08443"></a>
enum <br class="typebreak"/>
DataStructures::Multilist:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>sortState</b></td></tr>
<tr class="separator:ad28ab4936d56170b875d73ede3b08443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4e984b62dd496b3c91cf7ca526f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adff4e984b62dd496b3c91cf7ca526f9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ascendingSort</b></td></tr>
<tr class="separator:adff4e984b62dd496b3c91cf7ca526f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8407a503dfe3a7ddb87351504e99f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8407a503dfe3a7ddb87351504e99f91"></a>
<a class="el" href="_d_s___multilist_8h.html#a8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>variableMultilistType</b></td></tr>
<tr class="separator:ab8407a503dfe3a7ddb87351504e99f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;const MultilistType _MultilistType, class _DataType, class _KeyType = _DataType, class _IndexType = DefaultIndexType&gt;<br/>
class DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;</h3>

<p>The multilist, representing an abstract data type that generally holds lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_MultilistType</td><td>What type of list this is, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_d_s___multilist_8h.html#a8387ff66ed3a8c8a6c0528ddb5650a5b" title="What algorithm to use to store the data for the Multilist. ">MultilistType</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_DataType</td><td>What type of data this list holds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_KeyType</td><td>If a function takes a key to sort on, what type of key this is. The comparison operator between _DataType and _KeyType must be defined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_IndexType</td><td>What variable type to use for indices </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8ea6e9cc49fa6c858114db3540264d7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::ClearPointers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocateSmallBlocks</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>__LINE__</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties the list, first calling RakNet::OP_Delete on all items. </p>
<p>The list is not deallocated if it is small, unless <em>deallocateSmallBlocks</em> is true </p>

</div>
</div>
<a class="anchor" id="aacbab3fd63f299185141b0c4a62e9ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::IsSorted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the list is currently believed to be in a sorted state. </p>
<p>Doesn't actually check for sortedness, just if <a class="el" href="class_data_structures_1_1_multilist.html#af7c98eb3dd4a13343695b810c5f6d2c4" title="Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to alrea...">Sort()</a> was recently called, or MultilistType is ML_ORDERED_LIST </p>

</div>
</div>
<a class="anchor" id="afe3f119b9f715a88fc6dd356689f7e72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">const _DataType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>__LINE__</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unordered list, stack is LIFO QUEUE is FIFO Ordered list is inserted in order </p>

</div>
</div>
<a class="anchor" id="a33dd81344fc1e3ddada972637cfe27c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::RemoveAtIndex </td>
          <td>(</td>
          <td class="paramtype">_IndexType&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>line</em> = <code>__LINE__</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unordered list, removes at index indicated, swaps last element with that element. Otherwise, array is shifted left to overwrite removed element. </p>
<p>Index[0] returns the same as <a class="el" href="class_data_structures_1_1_multilist.html#a09e7c33fe9587c1902ed1551d720f7b7" title="Gets or removes and gets an element from the list, according to the same rules as Push()...">Pop()</a> for a queue. Same as <a class="el" href="class_data_structures_1_1_multilist.html#a5788e4bea29895d318226b5b943d5954" title="Same as Pop() and Peek(), except FIFO and LIFO are reversed. ">PopOpposite()</a> for the list and ordered list </p>

</div>
</div>
<a class="anchor" id="a054b07faf5e383569219911f18615a39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::SetMultilistType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_d_s___multilist_8h.html#a8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a>&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes what type of list this is. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Template must be defined with ML_VARIABLE_DURING_RUNTIME for this to do anything </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mlType</td><td>Any value of the enum MultilistType, except ML_VARIABLE_DURING_RUNTIME </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a219bfa477ce7722e32462e97c6876634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::SetSortOrder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defaults to ascending. </p>
<p>Used by <a class="el" href="class_data_structures_1_1_multilist.html#af7c98eb3dd4a13343695b810c5f6d2c4" title="Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to alrea...">Sort()</a>, and by ML_ORDERED_LIST </p>

</div>
</div>
<a class="anchor" id="af7c98eb3dd4a13343695b810c5f6d2c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to already be sorted. </p>
<p>However, if <em>force</em> is true, it will also resort the ordered list, useful if the comparison operator between _KeyType and _DataType would now return different results Once the list is sorted, further operations to lookup by key will be log2(n) until the list is modified </p>

</div>
</div>
<a class="anchor" id="a3d07bd2615004b6903a6ae8387238fa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::TagSorted </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the list to be remembered as sorted. </p>
<p>Optimization if the source is sorted already </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aaa5f425e786988300c1cc1c782173b4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType  = _DataType, class _IndexType  = DefaultIndexType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_IndexType <a class="el" href="class_data_structures_1_1_multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::preallocationSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How many bytes the user chose to preallocate Won't automatically deallocate below this </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/temportalflux/ChampNet/ChampNet/Libs/include/RakNet/<a class="el" href="_d_s___multilist_8h_source.html">DS_Multilist.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
