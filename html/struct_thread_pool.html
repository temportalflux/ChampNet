<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ChampNet: ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ChampNet
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="struct_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09fde0ca678340723840fae1dcda51a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a09fde0ca678340723840fae1dcda51a2">StartThreads</a> (int numThreads, int stackSize, void *(*_perThreadInit)()=0, void(*_perThreadDeinit)(void *)=0)</td></tr>
<tr class="separator:a09fde0ca678340723840fae1dcda51a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bca8ada8b0f6c30ee3c49b90a1d31e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2bca8ada8b0f6c30ee3c49b90a1d31e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetThreadDataInterface</b> (<a class="el" href="class_thread_data_interface.html">ThreadDataInterface</a> *tdi, void *context)</td></tr>
<tr class="separator:ad2bca8ada8b0f6c30ee3c49b90a1d31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b8ba41d96c5f0f814ae0acabfcdfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93b8ba41d96c5f0f814ae0acabfcdfc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#ad93b8ba41d96c5f0f814ae0acabfcdfc">StopThreads</a> (void)</td></tr>
<tr class="memdesc:ad93b8ba41d96c5f0f814ae0acabfcdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all threads. <br/></td></tr>
<tr class="separator:ad93b8ba41d96c5f0f814ae0acabfcdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f64a8c4a4400106a2d7d03f7f9de132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a5f64a8c4a4400106a2d7d03f7f9de132">AddInput</a> (OutputType(*workerThreadCallback)(InputType, bool *returnOutput, void *perThreadData), InputType inputData)</td></tr>
<tr class="separator:a5f64a8c4a4400106a2d7d03f7f9de132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833f8cc619dbf051c525c2ecd7ce78a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a833f8cc619dbf051c525c2ecd7ce78a0">AddOutput</a> (OutputType outputData)</td></tr>
<tr class="separator:a833f8cc619dbf051c525c2ecd7ce78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d6c332e4c48bc99dc5750dfd5fcdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a925d6c332e4c48bc99dc5750dfd5fcdd">HasOutput</a> (void)</td></tr>
<tr class="separator:a925d6c332e4c48bc99dc5750dfd5fcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d517170f4b61211325ac5c9717e32e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a5d517170f4b61211325ac5c9717e32e1">HasOutputFast</a> (void)</td></tr>
<tr class="separator:a5d517170f4b61211325ac5c9717e32e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ae43b7b3581b5ae9803c7cae7b724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#aac1ae43b7b3581b5ae9803c7cae7b724">HasInput</a> (void)</td></tr>
<tr class="separator:aac1ae43b7b3581b5ae9803c7cae7b724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde82517b452d9a74e91114a3783ce02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#adde82517b452d9a74e91114a3783ce02">HasInputFast</a> (void)</td></tr>
<tr class="separator:adde82517b452d9a74e91114a3783ce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568e3e2035977a38ad35aeee74ed7388"><td class="memItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a568e3e2035977a38ad35aeee74ed7388">GetOutput</a> (void)</td></tr>
<tr class="separator:a568e3e2035977a38ad35aeee74ed7388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0cc5c3c8786fc49f60aef34160cbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e0cc5c3c8786fc49f60aef34160cbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#af1e0cc5c3c8786fc49f60aef34160cbd">Clear</a> (void)</td></tr>
<tr class="memdesc:af1e0cc5c3c8786fc49f60aef34160cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears internal buffers. <br/></td></tr>
<tr class="separator:af1e0cc5c3c8786fc49f60aef34160cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024e2da38f846fc76d1fb16cf13c1b90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a024e2da38f846fc76d1fb16cf13c1b90">LockInput</a> (void)</td></tr>
<tr class="separator:a024e2da38f846fc76d1fb16cf13c1b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710a554919e550501f9f06ab61e1d911"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710a554919e550501f9f06ab61e1d911"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a710a554919e550501f9f06ab61e1d911">UnlockInput</a> (void)</td></tr>
<tr class="memdesc:a710a554919e550501f9f06ab61e1d911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the input buffer after you are done with the functions InputSize, GetInputAtIndex, and RemoveInputAtIndex. <br/></td></tr>
<tr class="separator:a710a554919e550501f9f06ab61e1d911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7631f35a83c4f992b881174b6c8eff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c7631f35a83c4f992b881174b6c8eff"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a0c7631f35a83c4f992b881174b6c8eff">InputSize</a> (void)</td></tr>
<tr class="memdesc:a0c7631f35a83c4f992b881174b6c8eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the input queue. <br/></td></tr>
<tr class="separator:a0c7631f35a83c4f992b881174b6c8eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09194411e4f4d87804111459fad24522"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09194411e4f4d87804111459fad24522"></a>
InputType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a09194411e4f4d87804111459fad24522">GetInputAtIndex</a> (unsigned index)</td></tr>
<tr class="memdesc:a09194411e4f4d87804111459fad24522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input at a specified index. <br/></td></tr>
<tr class="separator:a09194411e4f4d87804111459fad24522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e41bfe6660b1a55cbf14b99b77defac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e41bfe6660b1a55cbf14b99b77defac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a7e41bfe6660b1a55cbf14b99b77defac">RemoveInputAtIndex</a> (unsigned index)</td></tr>
<tr class="memdesc:a7e41bfe6660b1a55cbf14b99b77defac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove input from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br/></td></tr>
<tr class="separator:a7e41bfe6660b1a55cbf14b99b77defac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384ba5c62d60ac2e12e3f8aeea30d8bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a384ba5c62d60ac2e12e3f8aeea30d8bc">LockOutput</a> (void)</td></tr>
<tr class="separator:a384ba5c62d60ac2e12e3f8aeea30d8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5208df0686a4a76ecb3bbcc6ffcb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e5208df0686a4a76ecb3bbcc6ffcb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#af6e5208df0686a4a76ecb3bbcc6ffcb2">UnlockOutput</a> (void)</td></tr>
<tr class="memdesc:af6e5208df0686a4a76ecb3bbcc6ffcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the output buffer after you are done with the functions OutputSize, GetOutputAtIndex, and RemoveOutputAtIndex. <br/></td></tr>
<tr class="separator:af6e5208df0686a4a76ecb3bbcc6ffcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ebae170e7dbdbad6034ba69271f86f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2ebae170e7dbdbad6034ba69271f86f"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#ac2ebae170e7dbdbad6034ba69271f86f">OutputSize</a> (void)</td></tr>
<tr class="memdesc:ac2ebae170e7dbdbad6034ba69271f86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the output queue. <br/></td></tr>
<tr class="separator:ac2ebae170e7dbdbad6034ba69271f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45848613e8230e5324edabe40fcde9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade45848613e8230e5324edabe40fcde9"></a>
OutputType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#ade45848613e8230e5324edabe40fcde9">GetOutputAtIndex</a> (unsigned index)</td></tr>
<tr class="memdesc:ade45848613e8230e5324edabe40fcde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output at a specified index. <br/></td></tr>
<tr class="separator:ade45848613e8230e5324edabe40fcde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4958a8df475d6060bede0fa4af7faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb4958a8df475d6060bede0fa4af7faa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#afb4958a8df475d6060bede0fa4af7faa">RemoveOutputAtIndex</a> (unsigned index)</td></tr>
<tr class="memdesc:afb4958a8df475d6060bede0fa4af7faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove output from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br/></td></tr>
<tr class="separator:afb4958a8df475d6060bede0fa4af7faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d636d8a27645c6641d3b4cc7308f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568d636d8a27645c6641d3b4cc7308f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a568d636d8a27645c6641d3b4cc7308f6">ClearInput</a> (void)</td></tr>
<tr class="memdesc:a568d636d8a27645c6641d3b4cc7308f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the input queue. <br/></td></tr>
<tr class="separator:a568d636d8a27645c6641d3b4cc7308f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8d2d173ca5ddb99614ed5b9df1fb85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d8d2d173ca5ddb99614ed5b9df1fb85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a8d8d2d173ca5ddb99614ed5b9df1fb85">ClearOutput</a> (void)</td></tr>
<tr class="memdesc:a8d8d2d173ca5ddb99614ed5b9df1fb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all items from the output queue. <br/></td></tr>
<tr class="separator:a8d8d2d173ca5ddb99614ed5b9df1fb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b37c13ba8b9f67db4bd99ee4a5d811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b37c13ba8b9f67db4bd99ee4a5d811"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a90b37c13ba8b9f67db4bd99ee4a5d811">IsWorking</a> (void)</td></tr>
<tr class="memdesc:a90b37c13ba8b9f67db4bd99ee4a5d811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are any of the threads working, or is input or output available? <br/></td></tr>
<tr class="separator:a90b37c13ba8b9f67db4bd99ee4a5d811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad431a8d3f28af0ae5249c7e3b819307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad431a8d3f28af0ae5249c7e3b819307"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#aad431a8d3f28af0ae5249c7e3b819307">NumThreadsWorking</a> (void)</td></tr>
<tr class="memdesc:aad431a8d3f28af0ae5249c7e3b819307"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of currently active threads. <br/></td></tr>
<tr class="separator:aad431a8d3f28af0ae5249c7e3b819307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531920221fd17dce38b5da74b56f2eff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a531920221fd17dce38b5da74b56f2eff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thread_pool.html#a531920221fd17dce38b5da74b56f2eff">WasStarted</a> (void)</td></tr>
<tr class="memdesc:a531920221fd17dce38b5da74b56f2eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we call Start? <br/></td></tr>
<tr class="separator:a531920221fd17dce38b5da74b56f2eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e8e68979a7b0f1cc5b0fda7044a49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a870e8e68979a7b0f1cc5b0fda7044a49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Pause</b> (void)</td></tr>
<tr class="separator:a870e8e68979a7b0f1cc5b0fda7044a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16261d79beca0692cc4aa97ec204fd6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16261d79beca0692cc4aa97ec204fd6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Resume</b> (void)</td></tr>
<tr class="separator:a16261d79beca0692cc4aa97ec204fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6f77f4d6ec9d6f207f16fdb79b54fe2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f77f4d6ec9d6f207f16fdb79b54fe2a"></a>
template&lt;class ThreadInputType , class ThreadOutputType &gt; </td></tr>
<tr class="memitem:a6f77f4d6ec9d6f207f16fdb79b54fe2a"><td class="memTemplItemLeft" align="right" valign="top">friend&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RAK_THREAD_DECLARATION</b> (WorkerThread)</td></tr>
<tr class="separator:a6f77f4d6ec9d6f207f16fdb79b54fe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af047935d4a3523c4f6ce4e82af991a8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af047935d4a3523c4f6ce4e82af991a8b"></a>
<a class="el" href="class_rak_net_1_1_simple_mutex.html">RakNet::SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inputQueueMutex</b></td></tr>
<tr class="separator:af047935d4a3523c4f6ce4e82af991a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ddd8f74e243d5235e28f094a66882a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ddd8f74e243d5235e28f094a66882a"></a>
<a class="el" href="class_rak_net_1_1_simple_mutex.html">RakNet::SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>outputQueueMutex</b></td></tr>
<tr class="separator:a13ddd8f74e243d5235e28f094a66882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3489d0e612addb63b3fb86c3dc3062da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3489d0e612addb63b3fb86c3dc3062da"></a>
<a class="el" href="class_rak_net_1_1_simple_mutex.html">RakNet::SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>workingThreadCountMutex</b></td></tr>
<tr class="separator:a3489d0e612addb63b3fb86c3dc3062da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569bed4376f0b8893bdfeb2f3773dd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9569bed4376f0b8893bdfeb2f3773dd3"></a>
<a class="el" href="class_rak_net_1_1_simple_mutex.html">RakNet::SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>runThreadsMutex</b></td></tr>
<tr class="separator:a9569bed4376f0b8893bdfeb2f3773dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf9c53af2e2bae9560f1520ad63a1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacf9c53af2e2bae9560f1520ad63a1e9"></a>
void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>perThreadDataFactory</b> )()</td></tr>
<tr class="separator:aacf9c53af2e2bae9560f1520ad63a1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f69d2ba866370e2899980a06d29df4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f69d2ba866370e2899980a06d29df4"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>perThreadDataDestructor</b> )(void *)</td></tr>
<tr class="separator:ac2f69d2ba866370e2899980a06d29df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1210d4a8738dbb73fd4aba224a5437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba1210d4a8738dbb73fd4aba224a5437"></a>
<a class="el" href="class_data_structures_1_1_queue.html">DataStructures::Queue</a><br class="typebreak"/>
&lt; OutputType(*)(InputType, <br class="typebreak"/>
bool *, void *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inputFunctionQueue</b></td></tr>
<tr class="separator:aba1210d4a8738dbb73fd4aba224a5437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac808a3f10661465e2d83a4e7579dc880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac808a3f10661465e2d83a4e7579dc880"></a>
<a class="el" href="class_data_structures_1_1_queue.html">DataStructures::Queue</a>&lt; InputType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inputQueue</b></td></tr>
<tr class="separator:ac808a3f10661465e2d83a4e7579dc880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b76ae04819bd8b15bae573217b15735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b76ae04819bd8b15bae573217b15735"></a>
<a class="el" href="class_data_structures_1_1_queue.html">DataStructures::Queue</a>&lt; OutputType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>outputQueue</b></td></tr>
<tr class="separator:a6b76ae04819bd8b15bae573217b15735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e51a5c831a7dc16b0dad34203790b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5e51a5c831a7dc16b0dad34203790b0"></a>
<a class="el" href="class_thread_data_interface.html">ThreadDataInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>threadDataInterface</b></td></tr>
<tr class="separator:af5e51a5c831a7dc16b0dad34203790b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e346620f540fa4791d9916e51513b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e346620f540fa4791d9916e51513b1d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>tdiContext</b></td></tr>
<tr class="separator:a5e346620f540fa4791d9916e51513b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d53166bc98ac94b11d2f9346f8d61b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d53166bc98ac94b11d2f9346f8d61b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>runThreads</b></td></tr>
<tr class="separator:a6d53166bc98ac94b11d2f9346f8d61b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa44d9d22aaa0b45008a146d3d99dd22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa44d9d22aaa0b45008a146d3d99dd22"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numThreadsRunning</b></td></tr>
<tr class="separator:afa44d9d22aaa0b45008a146d3d99dd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31406cbf875ff36d9d0c5ba6207382c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31406cbf875ff36d9d0c5ba6207382c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numThreadsWorking</b></td></tr>
<tr class="separator:a31406cbf875ff36d9d0c5ba6207382c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d59aca67ec7d8e57f7a2abad94a24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a185d59aca67ec7d8e57f7a2abad94a24"></a>
<a class="el" href="class_rak_net_1_1_simple_mutex.html">RakNet::SimpleMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>numThreadsRunningMutex</b></td></tr>
<tr class="separator:a185d59aca67ec7d8e57f7a2abad94a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b8e31b094c460ba9b119a6a515ea40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03b8e31b094c460ba9b119a6a515ea40"></a>
<a class="el" href="class_rak_net_1_1_signaled_event.html">RakNet::SignaledEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>quitAndIncomingDataEvents</b></td></tr>
<tr class="separator:a03b8e31b094c460ba9b119a6a515ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class InputType, class OutputType&gt;<br/>
struct ThreadPool&lt; InputType, OutputType &gt;</h3>

<p>A simple class to create worker threads that processes a queue of functions with data. This class does not allocate or deallocate memory. It is up to the user to handle memory management. InputType and OutputType are stored directly in a queue. For large structures, if you plan to delete from the middle of the queue, you might wish to store pointers rather than the structures themselves so the array can shift efficiently. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5f64a8c4a4400106a2d7d03f7f9de132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::AddInput </td>
          <td>(</td>
          <td class="paramtype">OutputType(*)(InputType, bool *returnOutput, void *perThreadData)&#160;</td>
          <td class="paramname"><em>workerThreadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputType&#160;</td>
          <td class="paramname"><em>inputData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a function to a queue with data to pass to that function. This function will be called from the thread Memory management is your responsibility! This class does not allocate or deallocate memory. The best way to deallocate <em>inputData</em> is in userCallback. If you call EndThreads such that callbacks were not called, you can iterate through the inputQueue and deallocate all pending input data there The best way to deallocate output is as it is returned to you from GetOutput. Similarly, if you end the threads such that not all output was returned, you can iterate through outputQueue and deallocate it there. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">workerThreadCallback</td><td>The function to call from the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputData</td><td>The parameter to pass to <em>userCallback</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a833f8cc619dbf051c525c2ecd7ce78a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::AddOutput </td>
          <td>(</td>
          <td class="paramtype">OutputType&#160;</td>
          <td class="paramname"><em>outputData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds to the output queue Use it if you want to inject output into the same queue that the system uses. Normally you would not use this. Consider it a convenience function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputData</td><td>The output to inject </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a568e3e2035977a38ad35aeee74ed7388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputType <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::GetOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the output of a call to <em>userCallback</em> HasOutput must return true before you call this function. Otherwise it will assert. </p>
<dl class="section return"><dt>Returns</dt><dd>The output of <em>userCallback</em>. If you have different output signatures, it is up to you to encode the data to indicate this </dd></dl>

</div>
</div>
<a class="anchor" id="aac1ae43b7b3581b5ae9803c7cae7b724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if input from GetInput is waiting. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input is waiting, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adde82517b452d9a74e91114a3783ce02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInputFast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inaccurate but fast version of HasInput. If this returns true, you should still check HasInput for the real value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input is probably waiting, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a925d6c332e4c48bc99dc5750dfd5fcdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if output from GetOutput is waiting. </p>
<dl class="section return"><dt>Returns</dt><dd>true if output is waiting, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a5d517170f4b61211325ac5c9717e32e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutputFast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inaccurate but fast version of HasOutput. If this returns true, you should still check HasOutput for the real value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if output is probably waiting, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a024e2da38f846fc76d1fb16cf13c1b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockInput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock the input buffer before calling the functions InputSize, InputAtIndex, and RemoveInputAtIndex It is only necessary to lock the input or output while the threads are running </p>

</div>
</div>
<a class="anchor" id="a384ba5c62d60ac2e12e3f8aeea30d8bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock the output buffer before calling the functions OutputSize, OutputAtIndex, and RemoveOutputAtIndex It is only necessary to lock the input or output while the threads are running </p>

</div>
</div>
<a class="anchor" id="a09fde0ca678340723840fae1dcda51a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_thread_pool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::StartThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)()&#160;</td>
          <td class="paramname"><em>_perThreadInit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>_perThreadDeinit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the specified number of threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numThreads</td><td>The number of threads to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>0 for default (except on consoles). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_perThreadInit</td><td>User callback to return data stored per thread. Pass 0 if not needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_perThreadDeinit</td><td>User callback to destroy data stored per thread, created by _perThreadInit. Pass 0 if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/travis/build/temportalflux/ChampNet/ChampNet/Libs/include/RakNet/<a class="el" href="_thread_pool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
